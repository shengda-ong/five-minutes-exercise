# Architecture Plan for The 5 Minutes Exercise Backend (Revised)

This document describes the architecture for **The 5 Minutes Exercise** backend, updated to reflect the current design decisions around LLM agents, filtering, and planning.

---

## 1. Project Context

**The 5 Minutes Exercise** is a mobile-first application that generates short, personalised workout plans. The backend:

* Exposes a simple HTTP API for the mobile app.
* Stores a small curated exercise knowledge base (≈30 exercises for the prototype).
* Uses an LLM (Gemini) to:

  * Interpret user goals from free text.
  * Filter exercises from the knowledge base based on constraints and goals.
  * Generate a concrete 5‑minute workout plan.
* Validates the generated plan against the knowledge base to avoid hallucinations and ensure timing constraints.

The main output is a **5‑minute (300 seconds) exercise routine** built from 20‑second exercises and 5‑second rest intervals, using only known exercises.

---

## 2. High-Level Flow

1. **User goal input**

   * Mobile app prompts: *"What is your fitness goal?"*
   * User answers in free text, e.g. *"My goal is to lose calories, but I have knee injuries."*

2. **Goal understanding (GoalUnderstandingAgent)**

   * Backend sends this text to the LLM via `GeminiClient`.
   * LLM returns a **structured `GoalProfile`** with fields such as:

     * `primary_goal: str` (e.g. "fat loss", "general fitness", "rehab", "muscle gain").
     * `intensity: str` ("low" | "medium" | "high").
     * `constraints: list[str]` (e.g. ["knee injury"], ["no high impact"], etc.).
     * `additional_info: str | None`.

3. **Exercise retrieval and LLM-based filtering (ExerciseFilteringAgent)**

   * Backend loads the full set of exercises (≈30) from the DB.
   * The agent sends:

     * `GoalProfile`.
     * List of exercises (as simplified dicts) from the knowledge base.
   * LLM filters out exercises that violate constraints or are obviously misaligned with the goal.
   * Output: a **filtered list of exercise IDs** that are allowed for planning.

4. **Plan generation (PlanGenerationAgent)**

   * Input:

     * `GoalProfile`.
     * Filtered exercises from the knowledge base.
   * LLM generates a **5‑minute workout plan** composed of segments like:

     * 20 seconds of a specific exercise.
     * 5 seconds rest between exercises.
   * The agent enforces structure in the prompt:

     * Use only provided exercise IDs.
     * Total duration ≈ 300s (ideally exactly 300s).
     * Reasonable progression (no all‑out intensity at start or end, avoid harmful sequences).
   * Output is a **structured plan DTO** that references exercise IDs and segment durations.

5. **Plan validation (PlanValidationAgent)**

   * Pure backend (no LLM).
   * Validates that:

     * Every exercise ID in the plan exists in the knowledge base.
     * No extra fields or unknown exercises appear.
     * The total duration is as close to 300 seconds as possible and does not exceed it.
     * All segment durations and types follow expected constraints (e.g. 20s exercise, 5s rest, unless we explicitly extend the rules later).
   * Returns a validated `WorkoutPlan` domain object or raises a validation error.

6. **Response back to the mobile app**

   * API returns the final plan as JSON:

     * Stable `exercise_id`s that the app can later map to exercise videos.
     * Segment durations and ordering.
     * Optional metadata like total calories estimate.

---

## 3. Key Concepts & Data Models

### 3.1 GoalProfile (Domain)

Represents the user’s structured intent inside the **domain layer** (used by services and agents):

```python
class GoalProfile:
    primary_goal: str          # e.g. "fat loss", "general fitness", "rehab", "muscle gain"
    intensity: str             # "low" | "medium" | "high"
    constraints: list[str]     # e.g. ["knee injury", "no jumping"]
    additional_info: str | None
```

This is framework-agnostic and does not depend on LLM or Django.

### 3.2 DTOs vs Domain Objects

We distinguish between:

* **Domain objects** (e.g. `GoalProfile`, `WorkoutPlan`) used by business logic.
* **DTOs** in `core/` used for LLM I/O and API boundaries.

Examples:

* `GoalProfileDTO`: structured JSON returned directly from Gemini, with types and shapes optimised for LLM prompts.
* `PlanDTO`: raw plan structure generated by Gemini.
* Mappers convert between DTOs and domain objects so we can evolve prompts without breaking the domain model.

### 3.3 Exercise (Knowledge Base)

Stored in the **`exercises` app** as a Django model, with about 30 seed rows:

```python
Exercise:
  id: str (stable identifier, e.g. "jumping_jacks")
  name: str
  description: str
  muscle_groups: list[str]           # e.g. ["legs", "glutes", "cardio"]
  estimated_calories_per_min: float
  equipment_required: list[str]      # usually empty for this project
  impact_level: str                  # e.g. "low", "medium", "high"
  contraindications: list[str]       # optional risk tags, e.g. ["knee", "back"]
```

### 3.4 WorkoutPlan & PlanBlock (Domain)

Domain representation of the final workout:

```python
class PlanBlockType(StrEnum):
    EXERCISE = "exercise"
    REST = "rest"

class PlanBlock:
    type: PlanBlockType
    exercise_id: str | None          # set only when type == EXERCISE
    duration_seconds: int            # e.g. 20 or 5

class WorkoutPlan:
    goal_profile: GoalProfile
    total_duration_seconds: int      # should be 300
    blocks: list[PlanBlock]
```

This structure is straightforward to expose through the API and to map on the frontend.

---

## 4. Django App Structure

Proposed Django apps and modules:

* `core/`

  * `gemini_client.py` – low-level Gemini API wrapper.
  * DTOs for LLM I/O.
  * Common exceptions (e.g. `AIServiceError`).

* `exercises/`

  * `models.py` – `Exercise` model.
  * `repositories.py` – `ExerciseRepository` (e.g. `list_all()`, `get_by_ids()`).
  * `serializers.py` (if using DRF) for returning exercises directly if needed.

* `plans/`

  * `domain.py` – `GoalProfile`, `PlanBlock`, `WorkoutPlan`, etc.
  * `services.py` – agents and orchestrating services:

    * `GoalUnderstandingAgent`
    * `ExerciseFilteringAgent`
    * `PlanGenerationAgent`
    * `PlanValidationAgent`
    * `RecommendationService` (high-level orchestrator)

* `api/` (or `plans/api.py` if kept small)

  * HTTP views / DRF viewsets.
  * Request/response serializers.

This keeps LLM concerns in `core/` and domain/service logic in `plans/`.

---

## 5. LLM Integration & Agents

### 5.1 GeminiClient (Infrastructure)

`GeminiClient` is a low-level wrapper responsible for:

* Building prompts.
* Calling Gemini APIs.
* Parsing JSON / schemas into DTOs.
* Raising `AIServiceError` on failure.

It should **not** know about Django models or high-level orchestration.

Example capability methods:

* `parse_goal_text(text: str) -> GoalProfileDTO`
* `filter_exercises(goal_profile_dto, exercises_dto) -> FilteredExercisesDTO`
* `generate_plan(goal_profile_dto, filtered_exercises_dto) -> PlanDTO`

### 5.2 GoalUnderstandingAgent

Lives in `plans/services.py`, depends on `GeminiClient`.

Responsibilities:

* Accept raw user goal text.
* Call `GeminiClient.parse_goal_text(...)`.
* Map `GoalProfileDTO` → domain `GoalProfile`.
* Apply basic sanity checks (e.g. default `intensity` if missing).

Input:

* `text: str` from API layer.

Output:

* `GoalProfile` (domain).

### 5.3 ExerciseFilteringAgent

Responsibilities:

* Retrieve all exercises from `ExerciseRepository`.
* Convert exercises to LLM‑friendly dicts.
* Call `GeminiClient.filter_exercises(goal_profile_dto, exercises_dto)`.
* Map the filtered result back to a list of `Exercise` domain objects or just exercise IDs.

Input:

* `GoalProfile`.

Output:

* `list[Exercise]` or `list[str]` of allowed exercise IDs.

Notes:

* This step preserves flexibility: constraints may become more complex over time, and LLM reasoning can adapt without major code changes.

### 5.4 PlanGenerationAgent

Responsibilities:

* Accept `GoalProfile` and a filtered list of exercises.
* Build a planning prompt that enforces:

  * 20s work, 5s rest structure.
  * Total duration ≈ 300s.
  * Use only the allowed exercise IDs.
  * Sensible progression and safety (e.g. avoid explosive moves for rehab goals).
* Call `GeminiClient.generate_plan(...)`.
* Map the returned `PlanDTO` → domain `WorkoutPlan` (without trusting it yet).

Input:

* `GoalProfile`.
* `list[Exercise]` or IDs.

Output:

* `WorkoutPlan` (unvalidated) or `PlanDTO` that will be passed into validation.

### 5.5 PlanValidationAgent

Pure Python/domain logic, no LLM.

Responsibilities:

* Ensure all exercise IDs in the plan exist in the `ExerciseRepository`.
* Check total duration:

  * Sum of all `duration_seconds` must be as close as possible to 300s.
  * Must not exceed 300s.
* Enforce structure:

  * Only `exercise` and `rest` block types.
  * All `exercise` blocks have non-null `exercise_id`.
  * Duration values are sensible (typically 20 for exercise, 5 for rest for this project).
* Optionally perform simple intensity sanity checks (e.g. no more than N high-intensity blocks in a row for a "low" intensity goal) if we encode intensity tags in exercises.

Output:

* Validated `WorkoutPlan` or raises a custom `PlanValidationError`.

### 5.6 RecommendationService

High-level orchestrator (also in `plans/services.py`).

Rough flow:

1. `GoalUnderstandingAgent` → `GoalProfile`.
2. `ExerciseFilteringAgent` → filtered exercises.
3. `PlanGenerationAgent` → candidate plan.
4. `PlanValidationAgent` → validated `WorkoutPlan`.
5. Return the `WorkoutPlan` to the API layer.

This service hides the internal agent orchestration from views/controllers.

---

## 6. API Design

For the prototype, we keep the API simple.

### 6.1 Main Endpoint

`POST /api/v1/plans/`

Request body (simplified):

```json
{
  "goal_text": "My goal is to lose calories, but I have knee injuries."
}
```

Response body (simplified):

```json
{
  "total_duration_seconds": 300,
  "blocks": [
    {"type": "exercise", "exercise_id": "march_in_place", "duration_seconds": 20},
    {"type": "rest", "duration_seconds": 5},
    {"type": "exercise", "exercise_id": "air_punches", "duration_seconds": 20},
    {"type": "rest", "duration_seconds": 5}
    // ... until ~300 seconds total
  ]
}
```

The frontend can map `exercise_id` to videos and UI labels.

### 6.2 Errors

Use structured error responses, e.g.:

* 400 – validation error (invalid input, impossible goal, etc.).
* 422 – plan validation failure (hallucinated exercise IDs, wrong duration).
* 500 – unexpected errors, including `AIServiceError` from Gemini.

---

## 7. Testing Strategy

* **Unit tests**

  * `GeminiClient` prompt+response parsing (using fixtures and mocked Gemini responses).
  * `GoalUnderstandingAgent` behaviour given example texts.
  * `ExerciseFilteringAgent` logic around mapping and merging filtered IDs.
  * `PlanGenerationAgent` mapping from DTO to domain.
  * `PlanValidationAgent` for duration and ID checks.

* **Integration tests**

  * End-to-end flow from API request to final `WorkoutPlan`, mocking `GeminiClient`.

* **Data tests**

  * Seed fixtures for exercises to ensure the knowledge base is consistent and non-contradictory.

---

## 8. Future Extensions

* Extend `GoalProfile` with more fields (e.g. available equipment, experience level, schedule).
* Add support for different total durations (e.g. 10 or 15 minutes) while keeping the same plan structure.
* Improve safety by encoding more detailed contraindications in `Exercise` and checking them in `PlanValidationAgent`.
* Introduce analytics (track which plans are accepted/completed) to refine LLM prompts.

---

This revised plan aligns the backend with the desired agentic flow, keeps LLM usage focused, and ensures the generated plans are safe, structured, and easy to map to frontend exercise videos.
